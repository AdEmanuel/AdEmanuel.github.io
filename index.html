<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta http-equiv="X-UA-Compatible" content="IE=edge">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<meta name="generator" content="Asciidoctor 2.0.16">
<meta name="author" content="Processamento Digital de Imagens (DCA0445)">
<title>Página Pessoal - Adson Emanuel</title>
<link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700">
<style>
/*! Asciidoctor default stylesheet | MIT License | https://asciidoctor.org */
/* Uncomment the following line when using as a custom stylesheet */
/* @import "https://fonts.googleapis.com/css?family=Open+Sans:300,300italic,400,400italic,600,600italic%7CNoto+Serif:400,400italic,700,700italic%7CDroid+Sans+Mono:400,700"; */
html{font-family:sans-serif;-webkit-text-size-adjust:100%}
a{background:none}
a:focus{outline:thin dotted}
a:active,a:hover{outline:0}
h1{font-size:2em;margin:.67em 0}
b,strong{font-weight:bold}
abbr{font-size:.9em}
abbr[title]{cursor:help;border-bottom:1px dotted #dddddf;text-decoration:none}
dfn{font-style:italic}
hr{height:0}
mark{background:#ff0;color:#000}
code,kbd,pre,samp{font-family:monospace;font-size:1em}
pre{white-space:pre-wrap}
q{quotes:"\201C" "\201D" "\2018" "\2019"}
small{font-size:80%}
sub,sup{font-size:75%;line-height:0;position:relative;vertical-align:baseline}
sup{top:-.5em}
sub{bottom:-.25em}
img{border:0}
svg:not(:root){overflow:hidden}
figure{margin:0}
audio,video{display:inline-block}
audio:not([controls]){display:none;height:0}
fieldset{border:1px solid silver;margin:0 2px;padding:.35em .625em .75em}
legend{border:0;padding:0}
button,input,select,textarea{font-family:inherit;font-size:100%;margin:0}
button,input{line-height:normal}
button,select{text-transform:none}
button,html input[type=button],input[type=reset],input[type=submit]{-webkit-appearance:button;cursor:pointer}
button[disabled],html input[disabled]{cursor:default}
input[type=checkbox],input[type=radio]{padding:0}
button::-moz-focus-inner,input::-moz-focus-inner{border:0;padding:0}
textarea{overflow:auto;vertical-align:top}
table{border-collapse:collapse;border-spacing:0}
*,::before,::after{box-sizing:border-box}
html,body{font-size:100%}
body{background:#fff;color:rgba(0,0,0,.8);padding:0;margin:0;font-family:"Noto Serif","DejaVu Serif",serif;line-height:1;position:relative;cursor:auto;-moz-tab-size:4;-o-tab-size:4;tab-size:4;word-wrap:anywhere;-moz-osx-font-smoothing:grayscale;-webkit-font-smoothing:antialiased}
a:hover{cursor:pointer}
img,object,embed{max-width:100%;height:auto}
object,embed{height:100%}
img{-ms-interpolation-mode:bicubic}
.left{float:left!important}
.right{float:right!important}
.text-left{text-align:left!important}
.text-right{text-align:right!important}
.text-center{text-align:center!important}
.text-justify{text-align:justify!important}
.hide{display:none}
img,object,svg{display:inline-block;vertical-align:middle}
textarea{height:auto;min-height:50px}
select{width:100%}
.subheader,.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{line-height:1.45;color:#7a2518;font-weight:400;margin-top:0;margin-bottom:.25em}
div,dl,dt,dd,ul,ol,li,h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6,pre,form,p,blockquote,th,td{margin:0;padding:0}
a{color:#2156a5;text-decoration:underline;line-height:inherit}
a:hover,a:focus{color:#1d4b8f}
a img{border:0}
p{line-height:1.6;margin-bottom:1.25em;text-rendering:optimizeLegibility}
p aside{font-size:.875em;line-height:1.35;font-style:italic}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{font-family:"Open Sans","DejaVu Sans",sans-serif;font-weight:300;font-style:normal;color:#ba3925;text-rendering:optimizeLegibility;margin-top:1em;margin-bottom:.5em;line-height:1.0125em}
h1 small,h2 small,h3 small,#toctitle small,.sidebarblock>.content>.title small,h4 small,h5 small,h6 small{font-size:60%;color:#e99b8f;line-height:0}
h1{font-size:2.125em}
h2{font-size:1.6875em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.375em}
h4,h5{font-size:1.125em}
h6{font-size:1em}
hr{border:solid #dddddf;border-width:1px 0 0;clear:both;margin:1.25em 0 1.1875em}
em,i{font-style:italic;line-height:inherit}
strong,b{font-weight:bold;line-height:inherit}
small{font-size:60%;line-height:inherit}
code{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;font-weight:400;color:rgba(0,0,0,.9)}
ul,ol,dl{line-height:1.6;margin-bottom:1.25em;list-style-position:outside;font-family:inherit}
ul,ol{margin-left:1.5em}
ul li ul,ul li ol{margin-left:1.25em;margin-bottom:0}
ul.square li ul,ul.circle li ul,ul.disc li ul{list-style:inherit}
ul.square{list-style-type:square}
ul.circle{list-style-type:circle}
ul.disc{list-style-type:disc}
ol li ul,ol li ol{margin-left:1.25em;margin-bottom:0}
dl dt{margin-bottom:.3125em;font-weight:bold}
dl dd{margin-bottom:1.25em}
blockquote{margin:0 0 1.25em;padding:.5625em 1.25em 0 1.1875em;border-left:1px solid #ddd}
blockquote,blockquote p{line-height:1.6;color:rgba(0,0,0,.85)}
@media screen and (min-width:768px){h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2}
h1{font-size:2.75em}
h2{font-size:2.3125em}
h3,#toctitle,.sidebarblock>.content>.title{font-size:1.6875em}
h4{font-size:1.4375em}}
table{background:#fff;margin-bottom:1.25em;border:1px solid #dedede;word-wrap:normal}
table thead,table tfoot{background:#f7f8f7}
table thead tr th,table thead tr td,table tfoot tr th,table tfoot tr td{padding:.5em .625em .625em;font-size:inherit;color:rgba(0,0,0,.8);text-align:left}
table tr th,table tr td{padding:.5625em .625em;font-size:inherit;color:rgba(0,0,0,.8)}
table tr.even,table tr.alt{background:#f8f8f7}
table thead tr th,table tfoot tr th,table tbody tr td,table tr td,table tfoot tr td{line-height:1.6}
h1,h2,h3,#toctitle,.sidebarblock>.content>.title,h4,h5,h6{line-height:1.2;word-spacing:-.05em}
h1 strong,h2 strong,h3 strong,#toctitle strong,.sidebarblock>.content>.title strong,h4 strong,h5 strong,h6 strong{font-weight:400}
.center{margin-left:auto;margin-right:auto}
.stretch{width:100%}
.clearfix::before,.clearfix::after,.float-group::before,.float-group::after{content:" ";display:table}
.clearfix::after,.float-group::after{clear:both}
:not(pre).nobreak{word-wrap:normal}
:not(pre).nowrap{white-space:nowrap}
:not(pre).pre-wrap{white-space:pre-wrap}
:not(pre):not([class^=L])>code{font-size:.9375em;font-style:normal!important;letter-spacing:0;padding:.1em .5ex;word-spacing:-.15em;background:#f7f7f8;border-radius:4px;line-height:1.45;text-rendering:optimizeSpeed}
pre{color:rgba(0,0,0,.9);font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;line-height:1.45;text-rendering:optimizeSpeed}
pre code,pre pre{color:inherit;font-size:inherit;line-height:inherit}
pre>code{display:block}
pre.nowrap,pre.nowrap pre{white-space:pre;word-wrap:normal}
em em{font-style:normal}
strong strong{font-weight:400}
.keyseq{color:rgba(51,51,51,.8)}
kbd{font-family:"Droid Sans Mono","DejaVu Sans Mono",monospace;display:inline-block;color:rgba(0,0,0,.8);font-size:.65em;line-height:1.45;background:#f7f7f7;border:1px solid #ccc;border-radius:3px;box-shadow:0 1px 0 rgba(0,0,0,.2),inset 0 0 0 .1em #fff;margin:0 .15em;padding:.2em .5em;vertical-align:middle;position:relative;top:-.1em;white-space:nowrap}
.keyseq kbd:first-child{margin-left:0}
.keyseq kbd:last-child{margin-right:0}
.menuseq,.menuref{color:#000}
.menuseq b:not(.caret),.menuref{font-weight:inherit}
.menuseq{word-spacing:-.02em}
.menuseq b.caret{font-size:1.25em;line-height:.8}
.menuseq i.caret{font-weight:bold;text-align:center;width:.45em}
b.button::before,b.button::after{position:relative;top:-1px;font-weight:400}
b.button::before{content:"[";padding:0 3px 0 2px}
b.button::after{content:"]";padding:0 2px 0 3px}
p a>code:hover{color:rgba(0,0,0,.9)}
#header,#content,#footnotes,#footer{width:100%;margin:0 auto;max-width:62.5em;*zoom:1;position:relative;padding-left:.9375em;padding-right:.9375em}
#header::before,#header::after,#content::before,#content::after,#footnotes::before,#footnotes::after,#footer::before,#footer::after{content:" ";display:table}
#header::after,#content::after,#footnotes::after,#footer::after{clear:both}
#content{margin-top:1.25em}
#content::before{content:none}
#header>h1:first-child{color:rgba(0,0,0,.85);margin-top:2.25rem;margin-bottom:0}
#header>h1:first-child+#toc{margin-top:8px;border-top:1px solid #dddddf}
#header>h1:only-child,body.toc2 #header>h1:nth-last-child(2){border-bottom:1px solid #dddddf;padding-bottom:8px}
#header .details{border-bottom:1px solid #dddddf;line-height:1.45;padding-top:.25em;padding-bottom:.25em;padding-left:.25em;color:rgba(0,0,0,.6);display:flex;flex-flow:row wrap}
#header .details span:first-child{margin-left:-.125em}
#header .details span.email a{color:rgba(0,0,0,.85)}
#header .details br{display:none}
#header .details br+span::before{content:"\00a0\2013\00a0"}
#header .details br+span.author::before{content:"\00a0\22c5\00a0";color:rgba(0,0,0,.85)}
#header .details br+span#revremark::before{content:"\00a0|\00a0"}
#header #revnumber{text-transform:capitalize}
#header #revnumber::after{content:"\00a0"}
#content>h1:first-child:not([class]){color:rgba(0,0,0,.85);border-bottom:1px solid #dddddf;padding-bottom:8px;margin-top:0;padding-top:1rem;margin-bottom:1.25rem}
#toc{border-bottom:1px solid #e7e7e9;padding-bottom:.5em}
#toc>ul{margin-left:.125em}
#toc ul.sectlevel0>li>a{font-style:italic}
#toc ul.sectlevel0 ul.sectlevel1{margin:.5em 0}
#toc ul{font-family:"Open Sans","DejaVu Sans",sans-serif;list-style-type:none}
#toc li{line-height:1.3334;margin-top:.3334em}
#toc a{text-decoration:none}
#toc a:active{text-decoration:underline}
#toctitle{color:#7a2518;font-size:1.2em}
@media screen and (min-width:768px){#toctitle{font-size:1.375em}
body.toc2{padding-left:15em;padding-right:0}
#toc.toc2{margin-top:0!important;background:#f8f8f7;position:fixed;width:15em;left:0;top:0;border-right:1px solid #e7e7e9;border-top-width:0!important;border-bottom-width:0!important;z-index:1000;padding:1.25em 1em;height:100%;overflow:auto}
#toc.toc2 #toctitle{margin-top:0;margin-bottom:.8rem;font-size:1.2em}
#toc.toc2>ul{font-size:.9em;margin-bottom:0}
#toc.toc2 ul ul{margin-left:0;padding-left:1em}
#toc.toc2 ul.sectlevel0 ul.sectlevel1{padding-left:0;margin-top:.5em;margin-bottom:.5em}
body.toc2.toc-right{padding-left:0;padding-right:15em}
body.toc2.toc-right #toc.toc2{border-right-width:0;border-left:1px solid #e7e7e9;left:auto;right:0}}
@media screen and (min-width:1280px){body.toc2{padding-left:20em;padding-right:0}
#toc.toc2{width:20em}
#toc.toc2 #toctitle{font-size:1.375em}
#toc.toc2>ul{font-size:.95em}
#toc.toc2 ul ul{padding-left:1.25em}
body.toc2.toc-right{padding-left:0;padding-right:20em}}
#content #toc{border:1px solid #e0e0dc;margin-bottom:1.25em;padding:1.25em;background:#f8f8f7;border-radius:4px}
#content #toc>:first-child{margin-top:0}
#content #toc>:last-child{margin-bottom:0}
#footer{max-width:none;background:rgba(0,0,0,.8);padding:1.25em}
#footer-text{color:hsla(0,0%,100%,.8);line-height:1.44}
#content{margin-bottom:.625em}
.sect1{padding-bottom:.625em}
@media screen and (min-width:768px){#content{margin-bottom:1.25em}
.sect1{padding-bottom:1.25em}}
.sect1:last-child{padding-bottom:0}
.sect1+.sect1{border-top:1px solid #e7e7e9}
#content h1>a.anchor,h2>a.anchor,h3>a.anchor,#toctitle>a.anchor,.sidebarblock>.content>.title>a.anchor,h4>a.anchor,h5>a.anchor,h6>a.anchor{position:absolute;z-index:1001;width:1.5ex;margin-left:-1.5ex;display:block;text-decoration:none!important;visibility:hidden;text-align:center;font-weight:400}
#content h1>a.anchor::before,h2>a.anchor::before,h3>a.anchor::before,#toctitle>a.anchor::before,.sidebarblock>.content>.title>a.anchor::before,h4>a.anchor::before,h5>a.anchor::before,h6>a.anchor::before{content:"\00A7";font-size:.85em;display:block;padding-top:.1em}
#content h1:hover>a.anchor,#content h1>a.anchor:hover,h2:hover>a.anchor,h2>a.anchor:hover,h3:hover>a.anchor,#toctitle:hover>a.anchor,.sidebarblock>.content>.title:hover>a.anchor,h3>a.anchor:hover,#toctitle>a.anchor:hover,.sidebarblock>.content>.title>a.anchor:hover,h4:hover>a.anchor,h4>a.anchor:hover,h5:hover>a.anchor,h5>a.anchor:hover,h6:hover>a.anchor,h6>a.anchor:hover{visibility:visible}
#content h1>a.link,h2>a.link,h3>a.link,#toctitle>a.link,.sidebarblock>.content>.title>a.link,h4>a.link,h5>a.link,h6>a.link{color:#ba3925;text-decoration:none}
#content h1>a.link:hover,h2>a.link:hover,h3>a.link:hover,#toctitle>a.link:hover,.sidebarblock>.content>.title>a.link:hover,h4>a.link:hover,h5>a.link:hover,h6>a.link:hover{color:#a53221}
details,.audioblock,.imageblock,.literalblock,.listingblock,.stemblock,.videoblock{margin-bottom:1.25em}
details{margin-left:1.25rem}
details>summary{cursor:pointer;display:block;position:relative;line-height:1.6;margin-bottom:.625rem;-webkit-tap-highlight-color:transparent}
details>summary::before{content:"";border:solid transparent;border-left:solid;border-width:.3em 0 .3em .5em;position:absolute;top:.5em;left:-1.25rem;transform:translateX(15%)}
details[open]>summary::before{border:solid transparent;border-top:solid;border-width:.5em .3em 0;transform:translateY(15%)}
details>summary::after{content:"";width:1.25rem;height:1em;position:absolute;top:.3em;left:-1.25rem}
.admonitionblock td.content>.title,.audioblock>.title,.exampleblock>.title,.imageblock>.title,.listingblock>.title,.literalblock>.title,.stemblock>.title,.openblock>.title,.paragraph>.title,.quoteblock>.title,table.tableblock>.title,.verseblock>.title,.videoblock>.title,.dlist>.title,.olist>.title,.ulist>.title,.qlist>.title,.hdlist>.title{text-rendering:optimizeLegibility;text-align:left;font-family:"Noto Serif","DejaVu Serif",serif;font-size:1rem;font-style:italic}
table.tableblock.fit-content>caption.title{white-space:nowrap;width:0}
.paragraph.lead>p,#preamble>.sectionbody>[class=paragraph]:first-of-type p{font-size:1.21875em;line-height:1.6;color:rgba(0,0,0,.85)}
.admonitionblock>table{border-collapse:separate;border:0;background:none;width:100%}
.admonitionblock>table td.icon{text-align:center;width:80px}
.admonitionblock>table td.icon img{max-width:none}
.admonitionblock>table td.icon .title{font-weight:bold;font-family:"Open Sans","DejaVu Sans",sans-serif;text-transform:uppercase}
.admonitionblock>table td.content{padding-left:1.125em;padding-right:1.25em;border-left:1px solid #dddddf;color:rgba(0,0,0,.6);word-wrap:anywhere}
.admonitionblock>table td.content>:last-child>:last-child{margin-bottom:0}
.exampleblock>.content{border:1px solid #e6e6e6;margin-bottom:1.25em;padding:1.25em;background:#fff;border-radius:4px}
.exampleblock>.content>:first-child{margin-top:0}
.exampleblock>.content>:last-child{margin-bottom:0}
.sidebarblock{border:1px solid #dbdbd6;margin-bottom:1.25em;padding:1.25em;background:#f3f3f2;border-radius:4px}
.sidebarblock>:first-child{margin-top:0}
.sidebarblock>:last-child{margin-bottom:0}
.sidebarblock>.content>.title{color:#7a2518;margin-top:0;text-align:center}
.exampleblock>.content>:last-child>:last-child,.exampleblock>.content .olist>ol>li:last-child>:last-child,.exampleblock>.content .ulist>ul>li:last-child>:last-child,.exampleblock>.content .qlist>ol>li:last-child>:last-child,.sidebarblock>.content>:last-child>:last-child,.sidebarblock>.content .olist>ol>li:last-child>:last-child,.sidebarblock>.content .ulist>ul>li:last-child>:last-child,.sidebarblock>.content .qlist>ol>li:last-child>:last-child{margin-bottom:0}
.literalblock pre,.listingblock>.content>pre{border-radius:4px;overflow-x:auto;padding:1em;font-size:.8125em}
@media screen and (min-width:768px){.literalblock pre,.listingblock>.content>pre{font-size:.90625em}}
@media screen and (min-width:1280px){.literalblock pre,.listingblock>.content>pre{font-size:1em}}
.literalblock pre,.listingblock>.content>pre:not(.highlight),.listingblock>.content>pre[class=highlight],.listingblock>.content>pre[class^="highlight "]{background:#f7f7f8}
.literalblock.output pre{color:#f7f7f8;background:rgba(0,0,0,.9)}
.listingblock>.content{position:relative}
.listingblock code[data-lang]::before{display:none;content:attr(data-lang);position:absolute;font-size:.75em;top:.425rem;right:.5rem;line-height:1;text-transform:uppercase;color:inherit;opacity:.5}
.listingblock:hover code[data-lang]::before{display:block}
.listingblock.terminal pre .command::before{content:attr(data-prompt);padding-right:.5em;color:inherit;opacity:.5}
.listingblock.terminal pre .command:not([data-prompt])::before{content:"$"}
.listingblock pre.highlightjs{padding:0}
.listingblock pre.highlightjs>code{padding:1em;border-radius:4px}
.listingblock pre.prettyprint{border-width:0}
.prettyprint{background:#f7f7f8}
pre.prettyprint .linenums{line-height:1.45;margin-left:2em}
pre.prettyprint li{background:none;list-style-type:inherit;padding-left:0}
pre.prettyprint li code[data-lang]::before{opacity:1}
pre.prettyprint li:not(:first-child) code[data-lang]::before{display:none}
table.linenotable{border-collapse:separate;border:0;margin-bottom:0;background:none}
table.linenotable td[class]{color:inherit;vertical-align:top;padding:0;line-height:inherit;white-space:normal}
table.linenotable td.code{padding-left:.75em}
table.linenotable td.linenos{border-right:1px solid;opacity:.35;padding-right:.5em}
pre.pygments .lineno{border-right:1px solid;opacity:.35;display:inline-block;margin-right:.75em}
pre.pygments .lineno::before{content:"";margin-right:-.125em}
.quoteblock{margin:0 1em 1.25em 1.5em;display:table}
.quoteblock:not(.excerpt)>.title{margin-left:-1.5em;margin-bottom:.75em}
.quoteblock blockquote,.quoteblock p{color:rgba(0,0,0,.85);font-size:1.15rem;line-height:1.75;word-spacing:.1em;letter-spacing:0;font-style:italic;text-align:justify}
.quoteblock blockquote{margin:0;padding:0;border:0}
.quoteblock blockquote::before{content:"\201c";float:left;font-size:2.75em;font-weight:bold;line-height:.6em;margin-left:-.6em;color:#7a2518;text-shadow:0 1px 2px rgba(0,0,0,.1)}
.quoteblock blockquote>.paragraph:last-child p{margin-bottom:0}
.quoteblock .attribution{margin-top:.75em;margin-right:.5ex;text-align:right}
.verseblock{margin:0 1em 1.25em}
.verseblock pre{font-family:"Open Sans","DejaVu Sans",sans-serif;font-size:1.15rem;color:rgba(0,0,0,.85);font-weight:300;text-rendering:optimizeLegibility}
.verseblock pre strong{font-weight:400}
.verseblock .attribution{margin-top:1.25rem;margin-left:.5ex}
.quoteblock .attribution,.verseblock .attribution{font-size:.9375em;line-height:1.45;font-style:italic}
.quoteblock .attribution br,.verseblock .attribution br{display:none}
.quoteblock .attribution cite,.verseblock .attribution cite{display:block;letter-spacing:-.025em;color:rgba(0,0,0,.6)}
.quoteblock.abstract blockquote::before,.quoteblock.excerpt blockquote::before,.quoteblock .quoteblock blockquote::before{display:none}
.quoteblock.abstract blockquote,.quoteblock.abstract p,.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{line-height:1.6;word-spacing:0}
.quoteblock.abstract{margin:0 1em 1.25em;display:block}
.quoteblock.abstract>.title{margin:0 0 .375em;font-size:1.15em;text-align:center}
.quoteblock.excerpt>blockquote,.quoteblock .quoteblock{padding:0 0 .25em 1em;border-left:.25em solid #dddddf}
.quoteblock.excerpt,.quoteblock .quoteblock{margin-left:0}
.quoteblock.excerpt blockquote,.quoteblock.excerpt p,.quoteblock .quoteblock blockquote,.quoteblock .quoteblock p{color:inherit;font-size:1.0625rem}
.quoteblock.excerpt .attribution,.quoteblock .quoteblock .attribution{color:inherit;font-size:.85rem;text-align:left;margin-right:0}
p.tableblock:last-child{margin-bottom:0}
td.tableblock>.content{margin-bottom:1.25em;word-wrap:anywhere}
td.tableblock>.content>:last-child{margin-bottom:-1.25em}
table.tableblock,th.tableblock,td.tableblock{border:0 solid #dedede}
table.grid-all>*>tr>*{border-width:1px}
table.grid-cols>*>tr>*{border-width:0 1px}
table.grid-rows>*>tr>*{border-width:1px 0}
table.frame-all{border-width:1px}
table.frame-ends{border-width:1px 0}
table.frame-sides{border-width:0 1px}
table.frame-none>colgroup+*>:first-child>*,table.frame-sides>colgroup+*>:first-child>*{border-top-width:0}
table.frame-none>:last-child>:last-child>*,table.frame-sides>:last-child>:last-child>*{border-bottom-width:0}
table.frame-none>*>tr>:first-child,table.frame-ends>*>tr>:first-child{border-left-width:0}
table.frame-none>*>tr>:last-child,table.frame-ends>*>tr>:last-child{border-right-width:0}
table.stripes-all tr,table.stripes-odd tr:nth-of-type(odd),table.stripes-even tr:nth-of-type(even),table.stripes-hover tr:hover{background:#f8f8f7}
th.halign-left,td.halign-left{text-align:left}
th.halign-right,td.halign-right{text-align:right}
th.halign-center,td.halign-center{text-align:center}
th.valign-top,td.valign-top{vertical-align:top}
th.valign-bottom,td.valign-bottom{vertical-align:bottom}
th.valign-middle,td.valign-middle{vertical-align:middle}
table thead th,table tfoot th{font-weight:bold}
tbody tr th{background:#f7f8f7}
tbody tr th,tbody tr th p,tfoot tr th,tfoot tr th p{color:rgba(0,0,0,.8);font-weight:bold}
p.tableblock>code:only-child{background:none;padding:0}
p.tableblock{font-size:1em}
ol{margin-left:1.75em}
ul li ol{margin-left:1.5em}
dl dd{margin-left:1.125em}
dl dd:last-child,dl dd:last-child>:last-child{margin-bottom:0}
ol>li p,ul>li p,ul dd,ol dd,.olist .olist,.ulist .ulist,.ulist .olist,.olist .ulist{margin-bottom:.625em}
ul.checklist,ul.none,ol.none,ul.no-bullet,ol.no-bullet,ol.unnumbered,ul.unstyled,ol.unstyled{list-style-type:none}
ul.no-bullet,ol.no-bullet,ol.unnumbered{margin-left:.625em}
ul.unstyled,ol.unstyled{margin-left:0}
ul.checklist>li>p:first-child{margin-left:-1em}
ul.checklist>li>p:first-child>.fa-square-o:first-child,ul.checklist>li>p:first-child>.fa-check-square-o:first-child{width:1.25em;font-size:.8em;position:relative;bottom:.125em}
ul.checklist>li>p:first-child>input[type=checkbox]:first-child{margin-right:.25em}
ul.inline{display:flex;flex-flow:row wrap;list-style:none;margin:0 0 .625em -1.25em}
ul.inline>li{margin-left:1.25em}
.unstyled dl dt{font-weight:400;font-style:normal}
ol.arabic{list-style-type:decimal}
ol.decimal{list-style-type:decimal-leading-zero}
ol.loweralpha{list-style-type:lower-alpha}
ol.upperalpha{list-style-type:upper-alpha}
ol.lowerroman{list-style-type:lower-roman}
ol.upperroman{list-style-type:upper-roman}
ol.lowergreek{list-style-type:lower-greek}
.hdlist>table,.colist>table{border:0;background:none}
.hdlist>table>tbody>tr,.colist>table>tbody>tr{background:none}
td.hdlist1,td.hdlist2{vertical-align:top;padding:0 .625em}
td.hdlist1{font-weight:bold;padding-bottom:1.25em}
td.hdlist2{word-wrap:anywhere}
.literalblock+.colist,.listingblock+.colist{margin-top:-.5em}
.colist td:not([class]):first-child{padding:.4em .75em 0;line-height:1;vertical-align:top}
.colist td:not([class]):first-child img{max-width:none}
.colist td:not([class]):last-child{padding:.25em 0}
.thumb,.th{line-height:0;display:inline-block;border:4px solid #fff;box-shadow:0 0 0 1px #ddd}
.imageblock.left{margin:.25em .625em 1.25em 0}
.imageblock.right{margin:.25em 0 1.25em .625em}
.imageblock>.title{margin-bottom:0}
.imageblock.thumb,.imageblock.th{border-width:6px}
.imageblock.thumb>.title,.imageblock.th>.title{padding:0 .125em}
.image.left,.image.right{margin-top:.25em;margin-bottom:.25em;display:inline-block;line-height:0}
.image.left{margin-right:.625em}
.image.right{margin-left:.625em}
a.image{text-decoration:none;display:inline-block}
a.image object{pointer-events:none}
sup.footnote,sup.footnoteref{font-size:.875em;position:static;vertical-align:super}
sup.footnote a,sup.footnoteref a{text-decoration:none}
sup.footnote a:active,sup.footnoteref a:active{text-decoration:underline}
#footnotes{padding-top:.75em;padding-bottom:.75em;margin-bottom:.625em}
#footnotes hr{width:20%;min-width:6.25em;margin:-.25em 0 .75em;border-width:1px 0 0}
#footnotes .footnote{padding:0 .375em 0 .225em;line-height:1.3334;font-size:.875em;margin-left:1.2em;margin-bottom:.2em}
#footnotes .footnote a:first-of-type{font-weight:bold;text-decoration:none;margin-left:-1.05em}
#footnotes .footnote:last-of-type{margin-bottom:0}
#content #footnotes{margin-top:-.625em;margin-bottom:0;padding:.75em 0}
.gist .file-data>table{border:0;background:#fff;width:100%;margin-bottom:0}
.gist .file-data>table td.line-data{width:99%}
div.unbreakable{page-break-inside:avoid}
.big{font-size:larger}
.small{font-size:smaller}
.underline{text-decoration:underline}
.overline{text-decoration:overline}
.line-through{text-decoration:line-through}
.aqua{color:#00bfbf}
.aqua-background{background:#00fafa}
.black{color:#000}
.black-background{background:#000}
.blue{color:#0000bf}
.blue-background{background:#0000fa}
.fuchsia{color:#bf00bf}
.fuchsia-background{background:#fa00fa}
.gray{color:#606060}
.gray-background{background:#7d7d7d}
.green{color:#006000}
.green-background{background:#007d00}
.lime{color:#00bf00}
.lime-background{background:#00fa00}
.maroon{color:#600000}
.maroon-background{background:#7d0000}
.navy{color:#000060}
.navy-background{background:#00007d}
.olive{color:#606000}
.olive-background{background:#7d7d00}
.purple{color:#600060}
.purple-background{background:#7d007d}
.red{color:#bf0000}
.red-background{background:#fa0000}
.silver{color:#909090}
.silver-background{background:#bcbcbc}
.teal{color:#006060}
.teal-background{background:#007d7d}
.white{color:#bfbfbf}
.white-background{background:#fafafa}
.yellow{color:#bfbf00}
.yellow-background{background:#fafa00}
span.icon>.fa{cursor:default}
a span.icon>.fa{cursor:inherit}
.admonitionblock td.icon [class^="fa icon-"]{font-size:2.5em;text-shadow:1px 1px 2px rgba(0,0,0,.5);cursor:default}
.admonitionblock td.icon .icon-note::before{content:"\f05a";color:#19407c}
.admonitionblock td.icon .icon-tip::before{content:"\f0eb";text-shadow:1px 1px 2px rgba(155,155,0,.8);color:#111}
.admonitionblock td.icon .icon-warning::before{content:"\f071";color:#bf6900}
.admonitionblock td.icon .icon-caution::before{content:"\f06d";color:#bf3400}
.admonitionblock td.icon .icon-important::before{content:"\f06a";color:#bf0000}
.conum[data-value]{display:inline-block;color:#fff!important;background:rgba(0,0,0,.8);border-radius:50%;text-align:center;font-size:.75em;width:1.67em;height:1.67em;line-height:1.67em;font-family:"Open Sans","DejaVu Sans",sans-serif;font-style:normal;font-weight:bold}
.conum[data-value] *{color:#fff!important}
.conum[data-value]+b{display:none}
.conum[data-value]::after{content:attr(data-value)}
pre .conum[data-value]{position:relative;top:-.125em}
b.conum *{color:inherit!important}
.conum:not([data-value]):empty{display:none}
dt,th.tableblock,td.content,div.footnote{text-rendering:optimizeLegibility}
h1,h2,p,td.content,span.alt,summary{letter-spacing:-.01em}
p strong,td.content strong,div.footnote strong{letter-spacing:-.005em}
p,blockquote,dt,td.content,span.alt,summary{font-size:1.0625rem}
p{margin-bottom:1.25rem}
.sidebarblock p,.sidebarblock dt,.sidebarblock td.content,p.tableblock{font-size:1em}
.exampleblock>.content{background:#fffef7;border-color:#e0e0dc;box-shadow:0 1px 4px #e0e0dc}
.print-only{display:none!important}
@page{margin:1.25cm .75cm}
@media print{*{box-shadow:none!important;text-shadow:none!important}
html{font-size:80%}
a{color:inherit!important;text-decoration:underline!important}
a.bare,a[href^="#"],a[href^="mailto:"]{text-decoration:none!important}
a[href^="http:"]:not(.bare)::after,a[href^="https:"]:not(.bare)::after{content:"(" attr(href) ")";display:inline-block;font-size:.875em;padding-left:.25em}
abbr[title]{border-bottom:1px dotted}
abbr[title]::after{content:" (" attr(title) ")"}
pre,blockquote,tr,img,object,svg{page-break-inside:avoid}
thead{display:table-header-group}
svg{max-width:100%}
p,blockquote,dt,td.content{font-size:1em;orphans:3;widows:3}
h2,h3,#toctitle,.sidebarblock>.content>.title{page-break-after:avoid}
#header,#content,#footnotes,#footer{max-width:none}
#toc,.sidebarblock,.exampleblock>.content{background:none!important}
#toc{border-bottom:1px solid #dddddf!important;padding-bottom:0!important}
body.book #header{text-align:center}
body.book #header>h1:first-child{border:0!important;margin:2.5em 0 1em}
body.book #header .details{border:0!important;display:block;padding:0!important}
body.book #header .details span:first-child{margin-left:0!important}
body.book #header .details br{display:block}
body.book #header .details br+span::before{content:none!important}
body.book #toc{border:0!important;text-align:left!important;padding:0!important;margin:0!important}
body.book #toc,body.book #preamble,body.book h1.sect0,body.book .sect1>h2{page-break-before:always}
.listingblock code[data-lang]::before{display:block}
#footer{padding:0 .9375em}
.hide-on-print{display:none!important}
.print-only{display:block!important}
.hide-for-print{display:none!important}
.show-for-print{display:inherit!important}}
@media amzn-kf8,print{#header>h1:first-child{margin-top:1.25rem}
.sect1{padding:0!important}
.sect1+.sect1{border:0}
#footer{background:none}
#footer-text{color:rgba(0,0,0,.6);font-size:.9em}}
@media amzn-kf8{#header,#content,#footnotes,#footer{padding:0}}
</style>
</head>
<body class="book toc2 toc-left">
<div id="header">
<h1>Página Pessoal - Adson Emanuel</h1>
<div class="details">
<span id="author" class="author">Processamento Digital de Imagens (DCA0445)</span><br>
</div>
<div id="toc" class="toc2">
<div id="toctitle">Sumário</div>
<ul class="sectlevel1">
<li><a href="#_prefácio">Prefácio</a></li>
<li><a href="#_parte_i_processamento_de_imagens_no_domínio_espacial">Parte I: Processamento de Imagens no Domínio Espacial</a>
<ul class="sectlevel1">
<li><a href="#_1_manipulando_pixels_em_uma_imagem">1. Manipulando Pixels em uma Imagem</a>
<ul class="sectlevel2">
<li><a href="#_1_1_negativo_numa_região">1.1. Negativo numa região</a></li>
<li><a href="#_1_2_trocando_regiões">1.2. Trocando regiões</a></li>
</ul>
</li>
<li><a href="#_2_decomposição_de_imagens_em_planos_de_bits">2. Decomposição de imagens em planos de bits</a>
<ul class="sectlevel2">
<li><a href="#_2_1_desafio_esteganografia">2.1 Desafio Esteganografia</a></li>
</ul>
</li>
<li><a href="#_3_preenchendo_regiões">3. Preenchendo regiões</a>
<ul class="sectlevel2">
<li><a href="#_3_1_problemas_com_labeling">3.1 Problemas com labeling</a></li>
<li><a href="#_3_2_algoritmo_de_contagem_com_floodfill">3.2 Algoritmo de contagem com <strong>floodfill</strong></a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_parte_ii_processamento_de_imagens_no_domínio_da_frequência">Parte II: Processamento de Imagens no Domínio da Frequência</a>
<ul class="sectlevel1">
<li><a href="#_4_filtragem_no_domínio_da_frequência">4. Filtragem no Domínio da Frequência</a>
<ul class="sectlevel2">
<li><a href="#_4_1_filtro_homomórfico">4.1 Filtro Homomórfico</a></li>
</ul>
</li>
</ul>
</li>
<li><a href="#_parte_iii_segmentação_de_imagens">Parte III: Segmentação de imagens</a>
<ul class="sectlevel1">
<li><a href="#_5_detecção_de_bordas_com_o_algoritmo_de_canny">5. Detecção de bordas com o algoritmo de Canny</a>
<ul class="sectlevel2">
<li><a href="#_5_1_pontilhismo_com_canny">5.1 Pontilhismo com Canny</a></li>
<li><a href="#_5_2_quantização_vetorial_com_k_means">5.2 Quantização vetorial com k-means</a></li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
</div>
<div id="content">
<div class="sect1">
<h2 id="_prefácio">Prefácio</h2>
<div class="sectionbody">
<div class="paragraph text-justify">
<p>Esse site contém a resolução dos exercícios que foram propostos na disciplina Processamento Digital de Imagens ofertada pelo Departamento de Engenharia de Computação e Automação da UFRN e ministrada pelo professor Agostinho Brito. As informações acerca da disciplina podem ser vista em: <a href="https://agostinhobritojr.github.io/tutorial/pdi/" class="bare">https://agostinhobritojr.github.io/tutorial/pdi/</a>.</p>
</div>
<div class="paragraph text-justify">
<p>Os exercícios foram desenvolvidos em C++, sendo necessário ter a biblioteca OpenCV <a href="https://opencv.org/" class="bare">https://opencv.org/</a>. As regras de compilação dos códigos estão definidos no arquivo Makefile que está presente no site do curso. Dessa forma, para compilar e executar os códigos utiliza-se os seguintes comandos:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-SHELL" data-lang="SHELL">$ make &lt;nome_arquivo&gt;
$ ./&lt;nome_arquivo&gt; &lt;nome_da_imagem_ou_video&gt;</code></pre>
</div>
</div>
</div>
</div>
<h1 id="_parte_i_processamento_de_imagens_no_domínio_espacial" class="sect0">Parte I: Processamento de Imagens no Domínio Espacial</h1>
<div class="sect1">
<h2 id="_1_manipulando_pixels_em_uma_imagem">1. Manipulando Pixels em uma Imagem</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_1_1_negativo_numa_região">1.1. Negativo numa região</h3>
<div class="paragraph text-justify">
<p>O primeiro programa implementado chama-se <a href="#regions">regions.cpp</a>. Ele solicita ao usuário as coordenadas de dois pontos, P1 e P2, localizados dentro dos limites do tamanho da imagem e usa-os como vértices opostos na criação de um retângulo. A região triangular criada é exibida com o negativo da imagem no local correspondente.</p>
</div>
<div id="regions" class="listingblock">
<div class="title">regioes.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int, char**){
  cv::Mat image;
  cv::Vec3b val;

  image= cv::imread("biel.png",cv::IMREAD_COLOR);
  if(!image.data)
    std::cout &lt;&lt; "A imagem não foi aberta" &lt;&lt; std::endl;

  int cols, rows, x1, x2, y1 ,y2;

  cols = image.cols;
  rows = image.rows;

  std::cout &lt;&lt; "O tamanho da imagem, em pixels, que será editada é: " &lt;&lt; cols &lt;&lt; "x" &lt;&lt; rows &lt;&lt; std::endl;

  while (true){
    std::cout &lt;&lt; "Dessa forma, defina, respectivamente, as coordenadas x e y dos pontos P1 e P2." &lt;&lt; std::endl;
	std::cout &lt;&lt; "x1 = ";
	std::cin &gt;&gt; x1;
	std::cout &lt;&lt; "y1 = ";
	std::cin &gt;&gt; y1;


    if (x1 &lt; 0 || x1 &gt;= cols || y1 &lt; 0 || y1 &gt;= rows) {
      std::cout &lt;&lt; "Pelo menos um dos pontos está fora dos limites da imagem." &lt;&lt; std::endl;
    } else {
      std::cout &lt;&lt; "x2 = ";
      std::cin &gt;&gt; x2;
      std::cout &lt;&lt; "y2 = ";
      std::cin &gt;&gt; y2;

      // Verifique se os pontos formam um retângulo válido
      if (x2 &lt; 0 || x2 &gt;= cols || y2 &lt; 0 || y2 &gt;= rows || x1 &gt;= x2 || y1 &gt;= y2) {
        std::cout &lt;&lt; "Os pontos não formam um retângulo válido." &lt;&lt; std::endl;
      } else {
        break;  // As coordenadas são válidas, saia do loop
      }
    }
  }

  cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

  for(int i=x1;i&lt;x2;i++){
    for(int j=y1;j&lt;y2;j++){
	  val = image.at&lt;cv::Vec3b&gt;(i,j);

      val[0] = 255 - val[0];
      val[1] = 255 - val[1];
      val[2] = 255 - val[2];
      image.at&lt;cv::Vec3b&gt;(i,j)= val;
    }
  }

  cv::imshow("janela", image);
  cv::waitKey();

  cv::imwrite("biel_negativo.png", image);

  return 0;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Num primeiro momento se faz importante observar a presença de trechos de códigos que estão na implemntação acima e serão usados em diversas outras implementações. São eles: leitura e verificação, onde a imagem é aberta e se verifica se há algum erro com ela; criação e fechamento da janela onde a imagem será exibida; e o trecho que salva a nova imagem na memória.</p>
</div>
<div class="listingblock">
<div class="title">Leitura e Verificação</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">image= cv::imread("biel.png",cv::IMREAD_COLOR);
if(!image.data)
  std::cout &lt;&lt; "A imagem não foi aberta" &lt;&lt; std::endl;</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Criação e fechamento da Janela de Visualização</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

cv::imshow("janela", image);
cv::waitKey();</code></pre>
</div>
</div>
<div class="listingblock">
<div class="title">Salvando nova imagem</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">cv::imwrite("biel_negativo.png", image);</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Tratando agora do restante da implementação, os pontos máximos de largura e altura da imagem são obtidos e printados, para que o usuário saiba quais os limites ele deve respeitar ao inserir os pontos. Após isso, os vértices do retângulo onde será aplicado o negativo são solicitados ao usuário. Caso ele forneça pontos que estejam fora dos limites da imagem ou que não formem um retângulo válido o programa solicita que ele forneça novos pontos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">int cols, rows, x1, x2, y1 ,y2;

cols = image.cols;
rows = image.rows;

std::cout &lt;&lt; "O tamanho da imagem, em pixels, que será editada é: " &lt;&lt; cols &lt;&lt; "x" &lt;&lt; rows &lt;&lt; std::endl;

while (true){
  std::cout &lt;&lt; "Dessa forma, defina, respectivamente, as coordenadas x e y dos pontos P1 e P2." &lt;&lt; std::endl;
  std::cout &lt;&lt; "x1 = ";
  std::cin &gt;&gt; x1;
  std::cout &lt;&lt; "y1 = ";
  std::cin &gt;&gt; y1;

  // Verifique se os pontos estão dentro dos limites da imagem
  if (x1 &lt; 0 || x1 &gt;= cols || y1 &lt; 0 || y1 &gt;= rows) {
    std::cout &lt;&lt; "Pelo menos um dos pontos está fora dos limites da imagem." &lt;&lt; std::endl;
  } else {
    std::cout &lt;&lt; "x2 = ";
    std::cin &gt;&gt; x2;
    std::cout &lt;&lt; "y2 = ";
    std::cin &gt;&gt; y2;

    // Verifique se os pontos formam um retângulo válido
    if (x2 &lt; 0 || x2 &gt;= cols || y2 &lt; 0 || y2 &gt;= rows || x1 &gt;= x2 || y1 &gt;= y2) {
      std::cout &lt;&lt; "Os pontos não formam um retângulo válido." &lt;&lt; std::endl;
    } else {
      break;  // As coordenadas são válidas, saia do loop
    }
  }
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Em seguida, percorre-se o espaço do retângulo e atribui-se a vairável val as cores do pixel que está na posição atual. De posse dessa informação, o efeito negativo é aplicado ao subtrair cada valor de canal de cor do valor máximo possível (255). Por fim, os novos valores de cada canal de cor são atualizados.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">for(int i=x1;i&lt;x2;i++){
    for(int j=y1;j&lt;y2;j++){
	  val = image.at&lt;cv::Vec3b&gt;(i,j);

      val[0] = 255 - val[0];
      val[1] = 255 - val[1];
      val[2] = 255 - val[2];
      image.at&lt;cv::Vec3b&gt;(i,j)= val;
    }
  }</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Um exemplo de execução do programa pode ser visto a seguir.</p>
</div>
<div class="imageblock png">
<div class="content">
<img src="PDI/1/terminal_regions.png" alt="terminal_regions" width="627" height="122">
</div>
<div class="title">Figure 1. Terminal: regions.cpp</div>
</div>
<div id="biel" class="imageblock png">
<div class="content">
<img src="PDI/1/biel.png" alt="Lena" width="256" height="256">
</div>
<div class="title">Figure 2. Entrada - biel.png</div>
</div>
<div id="biel_negativo" class="imageblock png">
<div class="content">
<img src="PDI/1/biel_negativo.png" alt="biel_negativo" width="256" height="256">
</div>
<div class="title">Figure 3. Saída - biel_negativo.png</div>
</div>
</div>
<div class="sect2">
<h3 id="_1_2_trocando_regiões">1.2. Trocando regiões</h3>
<div class="paragraph text-justify">
<p>O programa <a href="#trocaregioes">trocaregioes.cpp</a> troca os quadrantes em diagonal na imagem.</p>
</div>
<div id="trocaregioes" class="listingblock">
<div class="title">trocaregioes.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int, char**){
  cv::Mat image;
  cv::Vec3b aux;

  image= cv::imread("Lena.png",cv::IMREAD_COLOR);
  if(!image.data)
    std::cout &lt;&lt; "nao abriu imagem.png" &lt;&lt; std::endl;

  cv::namedWindow("janela", cv::WINDOW_AUTOSIZE);

  for (int i = 0; i &lt; image.rows/2; i++) {
    for (int j = 0; j &lt; image.cols/2; j++) {
      aux = image.at&lt;cv::Vec3b&gt;(i,j);
      image.at&lt;cv::Vec3b&gt;(i,j) = image.at&lt;cv::Vec3b&gt;(i+image.rows/2,j+image.cols/2);
      image.at&lt;cv::Vec3b&gt;(i+image.rows/2,j+image.cols/2) = aux;

      aux = image.at&lt;cv::Vec3b&gt;(i+image.rows/2,j);
      image.at&lt;cv::Vec3b&gt;(i+image.rows/2,j) = image.at&lt;cv::Vec3b&gt;(i,j+image.cols/2);
      image.at&lt;cv::Vec3b&gt;(i,j+image.cols/2) = aux;
	}
  }

  cv::imshow("janela", image);
  cv::waitKey();

  cv::imwrite("Lena_trocaregioes.png", image);

  return 0;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>A troca das regiões da imagem foi feita a partir do aninhamento de dois laços for que irão percorrer metade das linhas e metade das colunas da imagem.</p>
</div>
<div class="paragraph text-justify">
<p>Dentro dos for’s, pode-se dizer que existem dois blocos de códigos, onde ambos fazem o uso da vairável auxilair trono. Num primeiro momento, a varíavel trono guarda as características do pixel do primeiro quadrante, esse pixel é substituído pelo pixel do quarto quadrante ao se acessar a posição (i+image.rows/2,j+image.cols/2) e então o pixel do quarto quadrante é atualizado ao receber o trono.</p>
</div>
<div class="paragraph text-justify">
<p>Esse mesmo procedimento se repete no segundo bloco de código, mas dessa vez  o trono é utilizado para fazer a troca entre os elementos do segundo quadrante, acessados na posição (i,j+image.cols/2)  e do terceiro quadrante, acessados na posição (i+image.rows/2,j).</p>
</div>
<div class="paragraph text-justify">
<p>Assim, ao fim das iterações do laço, as regiões são trocadas, como é possível averiguar na  <a href="#imagem">Lena_trocaregioes.png</a></p>
</div>
<div id="Lena_trocaregioes" class="imageblock png">
<div class="content">
<img src="PDI/1/Lena_trocaregioes.png" alt="Lena_trocaregioes" width="512" height="512">
</div>
<div class="title">Figure 4. Saída - Lena_trocaregioes.png</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_2_decomposição_de_imagens_em_planos_de_bits">2. Decomposição de imagens em planos de bits</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_2_1_desafio_esteganografia">2.1 Desafio Esteganografia</h3>
<div class="paragraph text-justify">
<p>O programa <a href="#recupera_imagem">recupera_imagem.cpp</a> recupera a imagem codificada de uma imagem resultante de esteganografia.</p>
</div>
<div id="recupera_imagem" class="listingblock">
<div class="title">recupera_imagem.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int argc, char**argv) {
  cv::Mat imagemEscondida, imagemFinal;
  cv::Vec3b valEscondida, valFinal;
  int nbits = 5;

  imagemFinal = cv::imread(argv[1], cv::IMREAD_COLOR);

   if (imagemFinal.empty()) {
    std::cout &lt;&lt; "imagem nao carregou corretamente" &lt;&lt; std::endl;
    return (-1);
  }

  const char* arg2 = argv[2];
  std::string nome_imagem = arg2;
  nome_imagem += ".png";

  imagemEscondida = imagemFinal.clone();

  for (int i = 0; i &lt; imagemFinal.rows; i++) {
    for (int j = 0; j &lt; imagemFinal.cols; j++) {

	  valFinal = imagemFinal.at&lt;cv::Vec3b&gt;(i, j);

      valEscondida[0] = valFinal[0] &lt;&lt; nbits;
      valEscondida[1] = valFinal[1] &lt;&lt; nbits;
      valEscondida[2] = valFinal[2] &lt;&lt; nbits;

      imagemEscondida.at&lt;cv::Vec3b&gt;(i, j) = valEscondida;

    }
  }

  imwrite(nome_imagem, imagemEscondida);

  return 0;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Neste código, a imagem que será processada tem seu nome digitado pelo usuário durante a chamada do programa. Então, ela tem seu nome resgatado, é aberta e  tem sua integridade testada a partir do código a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">imagemFinal = cv::imread(argv[1], cv::IMREAD_COLOR);

if (imagemFinal.empty()) {
  std::cout &lt;&lt; "imagem nao carregou corretamente" &lt;&lt; std::endl;
  return (-1);
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Logo após, é feito um tratamento para receber o nome da imagem escondida a partir da imagem esteganografada. Tal nome é passado pelo usuário pela linha de comando.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">const char* arg2 = argv[2];
std::string nome_imagem = arg2;
nome_imagem += ".png";</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Em seguida o objeto da clase Mat imagemFinal é clonado e atribuido ao objeto  imagemEscondida. Isso é feito pois, mesmo que o conteúdo da imagem vá mudar, alguns outros atributos precisam ser herdado, como, por exemplo, o tamanho e tipo.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">imagemEscondida = imagemFinal.clone();</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>O par de for aninhados é utilizado para percorrer as linhas e colunas da imagem Final.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">for (int i = 0; i &lt; imagemFinal.rows; i++) {
  for (int j = 0; j &lt; imagemFinal.cols; j++) {
    valFinal = imagemFinal.at&lt;cv::Vec3b&gt;(i, j);

    valEscondida[0] = valFinal[0] &lt;&lt; nbits;
    valEscondida[1] = valFinal[1] &lt;&lt; nbits;
    valEscondida[2] = valFinal[2] &lt;&lt; nbits;

    imagemEscondida.at&lt;cv::Vec3b&gt;(i, j) = valEscondida;

  }
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Dentro desses for’s, a vairável valFinal guarda as informações do pixels referentes a imagem Final.</p>
</div>
<div class="paragraph text-justify">
<p>No trecho seguinte, os nbits menos significativos de ValFinal são deslocados à esquerda. Como nbits é igual a 5, os bits que dizem respeito a imagem que está escondida passam a ocupar as três primeiras posições do vetor (a <a href="#ilustração_desloc">ilustracao_desloc</a> demostra como o deslocamento descrito ocorre). Então, imagemEscondida é atualizada com a valEscondida.</p>
</div>
<div id="ilustracao_desloc" class="imageblock png">
<div class="content">
<img src="PDI/2/ilustracao_desloc.png" alt="ilustracao_desloc" width="388" height="340">
</div>
<div class="title">Figure 5. Ilustração do deslocamento de bits feito no código.</div>
</div>
<div class="paragraph text-justify">
<p>Por fim, a imagem escondida é salva e atribui-se a ela o nome passado pelo usuário durante a execução do código.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP"> imwrite(nome_imagem, imagemEscondida);</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>O resultado final pode ser visto a seguir.</p>
</div>
<div id="desafio-esteganografia" class="imageblock png">
<div class="content">
<img src="PDI/2/desafio-esteganografia.png" alt="desafio-esteganografia" width="300" height="400">
</div>
<div class="title">Figure 6. Entrada - desafio-esteganografia.png</div>
</div>
<div id="im_recuperada" class="imageblock png">
<div class="content">
<img src="PDI/2/im_recuperada.png" alt="im_recuperada" width="300" height="400">
</div>
<div class="title">Figure 7. Saída - im_recuperada.png</div>
</div>
</div>
</div>
</div>
<div class="sect1">
<h2 id="_3_preenchendo_regiões">3. Preenchendo regiões</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_3_1_problemas_com_labeling">3.1 Problemas com labeling</h3>
<div class="paragraph text-justify">
<p>A técnica de <strong>labeling</strong> é um processo que consiste em atribuir rótulos únicos a regiões ou objetos de interesse em uma imagem. Nesse contexto, um dos algoritmos que pode ser utilizado para rotular uma imagem binária é o floodfill. Ele é capaz de preencher a área de uma imagem com uma cor específica ou um valor específico.</p>
</div>
<div class="paragraph text-justify">
<p>No código exemplo <em>labeling.cpp</em> (presente no site da disciplina do Prof. Agostinho) é possível verificar que caso existam mais de 255 objetos na cena, o processo de rotulação poderá ficar comprometido.</p>
</div>
<div class="paragraph text-justify">
<p>Tal situação ocorre quando 256° elemento está para ser rotulado e se dá pois, no caso em questão, o tipo de dado utilizado para representar os valores do pixel na posição (x,y) da imagem é um unsigned char e esse tipo de variável armazena 8 bits, ou seja, 255 valores. Dessa forma, depois de contados 255 objetos na cena, não há mais como rotular os próximos com algum tom de cinza, uma vez que a região a qual o pixel pertence é rotulada com tom de cinza igual ao número de contagem de objetos atual.</p>
</div>
<div class="paragraph text-justify">
<p>Para resolver esse problema uma possível solução é usar um tipo de dado que possua mais bits, permitindo assim, uma maior quantidade de rótulos. Um exemplo de tipo que pode ser implementado é uma matriz do tipo CV_16U, ao inves do uchar. Esse tipo de dado é capaz de armazenar 2 bytes (16 bits) o que permite que o intervalo de valores rotulado vá de 0 até 65535.</p>
</div>
</div>
<div class="sect2">
<h3 id="_3_2_algoritmo_de_contagem_com_floodfill">3.2 Algoritmo de contagem com <strong>floodfill</strong></h3>
<div class="paragraph">
<p>O programa <a href="#labeling2">labeling2.cpp</a> identifica regiões com ou sem buracos internos que existam na cena (<a href="#bolhas">bolhas.png</a>) e realiza a contagem desses elementos.</p>
</div>
<div id="labeling2" class="listingblock">
<div class="title">labeling2.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;

using namespace cv;

int main(int argc, char** argv) {
    cv::Mat image, realce;
    int width, height;
    int nobjects, nholes;

    cv::Point p;
    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

    if (!image.data) {
	std::cout &lt;&lt; "imagem nao carregou corretamente\n";
	return (-1);
    }

    width = image.cols;
    height = image.rows;
    std::cout &lt;&lt; width &lt;&lt; "x" &lt;&lt; height &lt;&lt; std::endl;

    p.x = 0;
    p.y = 0;

    //Lidando com buracos nas bordas
    for (int i = 0; i &lt; height; i++) {
	if (image.at&lt;uchar&gt;(i, 0) == 255) {
            p.x = 0;
            p.y = i;
            floodFill(image, p, 0);
	}

	if (image.at&lt;uchar&gt;(i, width - 1) == 255) {
	    p.x = width - 1;
	    p.y = i;
	    floodFill(image, p, 0);
	}
    }

    for (int j = 0; j &lt; width; j++) {
        if (image.at&lt;uchar&gt;(0, j) == 255) {
            p.x = j;
	    p.y = 0;
	    floodFill(image, p, 0);
	}

	if (image.at&lt;uchar&gt;(height - 1, j) == 255) {
            p.x = j;
	    p.y = height - 1;
	    floodFill(image, p, 0);
	}
    }

    cv::imshow("image", image);
    cv::imwrite("sem_bolhas_nas_bordas.png", image);
    cv::waitKey();

    p.x = 0;
    p.y = 0;
    cv::floodFill(image, p, 100);

    std::cout &lt;&lt; "Aqui 2\n";

    cv::imshow("image", image);
    cv::imwrite("cor_de_fundo_alterada.png", image);
    cv::waitKey();

    nholes = 0;

    for (int i = 0; i &lt; height; i++){
        for (int j = 0; j &lt; width; j++){
            if (image.at&lt;uchar&gt;(i, j) == 0){
                p.x = j;
                p.y = i;
                nholes++;
                cv::floodFill(image, p, 255);
            }
        }
    }

    cv::imshow("image", image);
    cv::imwrite("bolhas_brancas.png", image);
    cv::waitKey();

    p.x = 0;
    p.y = 0;
    cv::floodFill(image, p, 0);

    cv::imshow("image", image);
    cv::imwrite("bolhas_sem_buracos.png", image);
    cv::waitKey();

    nobjects = 0;

    for (int i = 0; i &lt; height; i++){
        for (int j = 0; j &lt; width; j++){
            if (image.at&lt;uchar&gt;(i, j) == 255){
                // achou um objeto
                nobjects++;
                // para o floodfill as coordenadas
                // x e y são trocadas.
                p.x = j;
                p.y = i;
                // preenche o objeto com o contador
                cv::floodFill(image, p, nobjects);
            }
        }
    }

    std::cout &lt;&lt; "A figura tem " &lt;&lt; nholes &lt;&lt; " bolhas com buracos e " &lt;&lt; nobjects - nholes &lt;&lt; " bolhas sem buracos.\n";
    std::cout &lt;&lt; "Ao todo a figura possui " &lt;&lt; nobjects &lt;&lt; " bolhas\n";
    cv::imshow("image", image);
    cv::imwrite("labeling2.png", image);
    cv::waitKey();

    return 0;
}</code></pre>
</div>
</div>
<div id="bolhas" class="imageblock png">
<div class="content">
<img src="PDI/3/bolhas.png" alt="bolhas" width="250" height="250">
</div>
<div class="title">Figure 8. Bolhas.png</div>
</div>
<div class="paragraph text-justify">
<p>O código abaixo diz respeito ao tratamento das bolhas que estão nas bordas da imagem. O primeiro for itera sobrea a altura e verificações são feitas em todos os pixels que estão na borda lateral esquerda, por meio da coordenada <em>(i, 0)</em>, e na borda lateral direita, por meio da coordenada <em>(i, width - 1)</em>. Se um pixel branco for encontrado em uma dessas extremidades, ele é usado como ponto de partida para a função floodfill que preenche essa região com valor 0 (preto).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">//Lidando com buracos nas bordas
for (int i = 0; i &lt; height; i++) {
    if (image.at&lt;uchar&gt;(i, 0) == 255) {
        p.x = 0;
	p.y = i;
	floodFill(image, p, 0);
    }

    if (image.at&lt;uchar&gt;(i, width - 1) == 255) {
        p.x = width - 1;
	p.y = i;
	floodFill(image, p, 0);
    }
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>A mesma ideia descrita é empregada no segundo for, mas dessa vez as iterações são feitas sobre o comprimeiro da imagem e são verificados os pixels que estão na borda superior, por meio da coordenada <em>(0, j)</em>, e na borda inferior, por meio da coordenada <em>(height - 1, j)</em>. Além disso, é gerada uma imagem da figura sem bolhas nas bordas (<a href="#sem_bolhas_nas_bordas">Cena sem bolhas nas bordas</a>)</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">for (int j = 0; j &lt; width; j++) {
    if (image.at&lt;uchar&gt;(0, j) == 255) {
        p.x = j;
	p.y = 0;
	floodFill(image, p, 0);
    }

    if (image.at&lt;uchar&gt;(height - 1, j) == 255) {
        p.x = j;
	p.y = height - 1;
	floodFill(image, p, 0);
    }
}

cv::imshow("image", image);
cv::imwrite("sem_bolhas_nas_bordas.png", image);
cv::waitKey();</code></pre>
</div>
</div>
<div id="sem_bolhas_nas_bordas" class="imageblock png">
<div class="content">
<img src="PDI/3/sem_bolhas_nas_bordas.png" alt="sem_bolhas_nas_bordas" width="250" height="250">
</div>
<div class="title">Figure 9. Cena sem bolhas nas bordas</div>
</div>
<div class="paragraph text-justify">
<p>Em seguida, buscando contar a quantidade de bolhas com buraco, foi mudada a cor de fundo da imagem para um tom de cinza arbritário, como é possível ver na Figura <a href="#cor_de_fundo_alterada">Cena cor de fundo alterada</a>. Com isso, apenas os buracos ficaram com a cor preta e então, ao se percorrer a imagem e encontrar essa cor, incrementasse o contador de bolhas com buraco e aplica-se o fllodfill para deixar a bolha toda branca (Figura <a href="#bolhas_brancas">Cena com as bolhas brancas</a>).</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">p.x = 0;
p.y = 0;
cv::floodFill(image, p, 100);

cv::imshow("image", image);
cv::imwrite("cor_de_fundo_alterada.png", image);
cv::waitKey();

nholes = 0;

for (int i = 0; i &lt; height; i++){
    for (int j = 0; j &lt; width; j++){
        if (image.at&lt;uchar&gt;(i, j) == 0){
            p.x = j;
            p.y = i;
            nholes++;
            cv::floodFill(image, p, 255);
        }
    }
}

cv::imshow("image", image);
cv::imwrite("bolhas_brancas.png", image);
cv::waitKey();</code></pre>
</div>
</div>
<div id="cor_de_fundo_alterada" class="imageblock png">
<div class="content">
<img src="PDI/3/cor_de_fundo_alterada.png" alt="cor_de_fundo_alterada" width="250" height="250">
</div>
<div class="title">Figure 10. Cena cor de fundo alterada</div>
</div>
<div id="bolhas_brancas" class="imageblock png">
<div class="content">
<img src="PDI/3/bolhas_brancas.png" alt="bolhas_brancas" width="250" height="250">
</div>
<div class="title">Figure 11. Cena com as bolhas brancas</div>
</div>
<div class="paragraph text-justify">
<p>Logo após, a cor de fundo da imagem é mudada de volta para o preto (Figura <a href="#bolhas_sem_buracos">Cena com bolhas sem buracos</a>) e obtem-se o número total de bolhas.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">p.x = 0;
p.y = 0;
cv::floodFill(image, p, 0);

cv::imshow("image", image);
cv::imwrite("bolhas_sem_buracos.png", image);
cv::waitKey();

nobjects = 0;

for (int i = 0; i &lt; height; i++){
    for (int j = 0; j &lt; width; j++){
        if (image.at&lt;uchar&gt;(i, j) == 255){
            // achou um objeto
            nobjects++;
            // para o floodfill as coordenadas
            // x e y são trocadas.
            p.x = j;
            p.y = i;
            // preenche o objeto com o contador
            cv::floodFill(image, p, nobjects);
        }
    }
}</code></pre>
</div>
</div>
<div id="bolhas_sem_buracos" class="imageblock png">
<div class="content">
<img src="PDI/3/bolhas_sem_buracos.png" alt="bolhas_sem_buracos" width="250" height="250">
</div>
<div class="title">Figure 12. Cena com bolhas sem buracos</div>
</div>
<div class="paragraph">
<p>Por fim, são printadas no terminal informações referentes a quantidade de bolhas com e sem buracos e obtem-se a imagem final do labeling para contagem de objetos.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">std::cout &lt;&lt; "A figura tem " &lt;&lt; nholes &lt;&lt; " bolhas com buracos e " &lt;&lt; nobjects - nholes &lt;&lt; " bolhas sem buracos.\n";	std::cout &lt;&lt; "Ao todo a figura possui " &lt;&lt; nobjects &lt;&lt; " bolhas\n";
cv::imshow("image", image);
cv::imwrite("labeling2.png", image);
cv::waitKey();</code></pre>
</div>
</div>
<div id="terminal_labeling2" class="imageblock png">
<div class="content">
<img src="PDI/3/terminal_labeling2.png" alt="terminal_labeling2" width="710" height="100">
</div>
<div class="title">Figure 13. Terminal - labeling2.cpp</div>
</div>
<div id="labeling2_out" class="imageblock png">
<div class="content">
<img src="PDI/3/labeling2.png" alt="labeling" width="250" height="250">
</div>
<div class="title">Figure 14. Saída final - Labeling2</div>
</div>
</div>
</div>
</div>
<h1 id="_parte_ii_processamento_de_imagens_no_domínio_da_frequência" class="sect0">Parte II: Processamento de Imagens no Domínio da Frequência</h1>
<div class="sect1">
<h2 id="_4_filtragem_no_domínio_da_frequência">4. Filtragem no Domínio da Frequência</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_4_1_filtro_homomórfico">4.1 Filtro Homomórfico</h3>
<div class="paragraph text-justify">
<p>Usando o programa dftfilter.cpp como base, implementou-se o programa homomorphic_filter.cpp que aplica o filtro homomórfico H(u,v). Tal filtro possui como objetivo principal melhorar imagens com iluminação irregular e tem sua função matemática definida por:</p>
</div>
<div id="FormulaHomomorfico" class="imageblock png">
<div class="content">
<img src="PDI/4/FormulaHomomorfico.png" alt="FormulaHomomorfico" width="350" height="250">
</div>
<div class="title">Figure 15. Fórmula do Filtro Homomórfico</div>
</div>
<div class="paragraph text-justify">
<p>onde, Do é uma constante positiva, e D(u,v) é a distância entre um ponto (u,v) no domínio da frequênciae e o centro do retângulo de frequência, ou seja:</p>
</div>
<div id="FormulaD" class="imageblock png">
<div class="content">
<img src="PDI/4/FormulaD.png" alt="FormulaD" width="350" height="250">
</div>
<div class="title">Figure 16. Fórmula para a distância D</div>
</div>
<div class="paragraph">
<p>Além disso, a constante <em>c</em> controla a inclinação da função à medida que ela realizar a transição entre gamma_L e gamma_H.</p>
</div>
<div class="paragraph">
<p>O código implementado pode ser visto a seguir:</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;vector&gt;
#include &lt;opencv2/opencv.hpp&gt;

void swapQuadrants(cv::Mat&amp; image) {
  cv::Mat tmp, A, B, C, D;

  // se a imagem tiver tamanho impar, recorta a regiao para o maior
  // tamanho par possivel (-2 = 1111...1110)
  image = image(cv::Rect(0, 0, image.cols &amp; -2, image.rows &amp; -2));

  int centerX = image.cols / 2;
  int centerY = image.rows / 2;

  // rearranja os quadrantes da transformada de Fourier de forma que
  // a origem fique no centro da imagem
  // A B   -&gt;  D C
  // C D       B A
  A = image(cv::Rect(0, 0, centerX, centerY));
  B = image(cv::Rect(centerX, 0, centerX, centerY));
  C = image(cv::Rect(0, centerY, centerX, centerY));
  D = image(cv::Rect(centerX, centerY, centerX, centerY));

  // swap quadrants (Top-Left with Bottom-Right)
  A.copyTo(tmp);
  D.copyTo(A);
  tmp.copyTo(D);

  // swap quadrant (Top-Right with Bottom-Left)
  C.copyTo(tmp);
  B.copyTo(C);
  tmp.copyTo(B);
}

void makeHomomorphicFilter(const cv::Mat &amp;image, cv::Mat &amp;filter){
  cv::Mat_&lt;float&gt; filter2D(image.rows, image.cols);
  int centerX = image.cols / 2;
  int centerY = image.rows / 2;
  float gh = 1.0, gl = 0.5, c = 2.0, D0 = 1.0;

  for (int i = 0; i &lt; image.rows; i++) {
    for (int j = 0; j &lt; image.cols; j++) {
    	float D = std::sqrt(std::pow(i - centerY, 2) + std::pow(j - centerX, 2));
        float H = (gh - gl) * (1 - std::exp(-c * (std::pow(D, 2) / (2 * std::pow(D0, 2))))) + gl;
        filter2D.at&lt;float&gt;(i, j) = H;
     }
   }

   cv::normalize(filter2D, filter2D, 0, 1, cv::NORM_MINMAX);
   cv::Mat planes[] = {cv::Mat_&lt;float&gt;(filter2D), cv::Mat::zeros(filter2D.size(), CV_32F)};
   cv::merge(planes, 2, filter);
}

int main(int argc, char** argv) {
  cv::Mat image, padded, complexImage;
  std::vector&lt;cv::Mat&gt; planos;

  image = imread(argv[1], cv::IMREAD_GRAYSCALE);
  if (image.empty()) {
    std::cout &lt;&lt; "Erro abrindo imagem" &lt;&lt; argv[1] &lt;&lt; std::endl;
    return EXIT_FAILURE;
  }

  // expande a imagem de entrada para o melhor tamanho no qual a DFT pode ser
  // executada, preenchendo com zeros a lateral inferior direita.
  int dft_M = cv::getOptimalDFTSize(image.rows);
  int dft_N = cv::getOptimalDFTSize(image.cols);
  cv::copyMakeBorder(image, padded, 0, dft_M - image.rows, 0, dft_N - image.cols, cv::BORDER_CONSTANT, cv::Scalar::all(0));

  // prepara a matriz complexa para ser preenchida
  // primeiro a parte real, contendo a imagem de entrada
  planos.push_back(cv::Mat_&lt;float&gt;(padded));
  // depois a parte imaginaria com valores nulos
  planos.push_back(cv::Mat::zeros(padded.size(), CV_32F));

  // combina os planos em uma unica estrutura de dados complexa
  cv::merge(planos, complexImage);

  // calcula a DFT
  cv::dft(complexImage, complexImage);
  swapQuadrants(complexImage);

  // cria o filtro homomórfico e aplica a filtragem de frequencia
  cv::Mat filter;
  makeHomomorphicFilter(complexImage, filter);
  cv::mulSpectrums(complexImage, filter, complexImage, 0);

  // calcula a DFT inversa
  swapQuadrants(complexImage);
  cv::idft(complexImage, complexImage);

  // planos[0] : Re(DFT(image)
  // planos[1] : Im(DFT(image)
  cv::split(complexImage, planos);

  // recorta a imagem filtrada para o tamanho original
  // selecionando a regiao de interesse (roi)
  cv::Rect roi(0, 0, image.cols, image.rows);
  cv::Mat result = planos[0](roi);

  // normaliza a parte real para exibicao
  cv::normalize(result, result, 0, 1, cv::NORM_MINMAX);

  cv::imshow("image", result);
  cv::imwrite("homomorphic-filter.png", result * 255);

  cv::waitKey();
  return EXIT_SUCCESS;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>No código, o filtro homomórifico é criado a partir da função makeHomomorphicFIlter, onde é implementado o cálculo descrito anteriormente. Dessa forma, o <em>g</em> do código corresponde ao  gama da função e os valores para <em>gh</em>, <em>gl</em>, <em>c</em> e <em>D0</em> foram definidos experimentalmente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">void makeHomomorphicFilter(const cv::Mat &amp;image, cv::Mat &amp;filter){
  cv::Mat_&lt;float&gt; filter2D(image.rows, image.cols);
  int centerX = image.cols / 2;
  int centerY = image.rows / 2;
  float gh = 1.0, gl = 0.5, c = 2.0, D0 = 1.0;

  for (int i = 0; i &lt; image.rows; i++) {
    for (int j = 0; j &lt; image.cols; j++) {
    	float D = std::sqrt(std::pow(i - centerY, 2) + std::pow(j - centerX, 2));
        float H = (gh - gl) * (1 - std::exp(-c * (std::pow(D, 2) / (2 * std::pow(D0, 2))))) + gl;
        filter2D.at&lt;float&gt;(i, j) = H;
     }
   }

   cv::normalize(filter2D, filter2D, 0, 1, cv::NORM_MINMAX);
   cv::Mat planes[] = {cv::Mat_&lt;float&gt;(filter2D), cv::Mat::zeros(filter2D.size(), CV_32F)};
   cv::merge(planes, 2, filter);
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Ao executar o código utilizando como entrada a Imagem <a href="#Parceria">Entrada do Filtro Homomórfico</a>, obteve-se a saída <a href="#out-homomorphic-filter">Saída do Filtro Homomórfico</a>.</p>
</div>
<div id="Parceria" class="imageblock png">
<div class="content">
<img src="PDI/4/Parceria.png" alt="Parceria" width="350" height="350">
</div>
<div class="title">Figure 17. Entrada do Filtro Homomórfico</div>
</div>
<div id="out-homomorphic-filter" class="imageblock png">
<div class="content">
<img src="PDI/4/out-homomorphic-filter.png" alt="out-homomorphic-filter" width="350" height="350">
</div>
<div class="title">Figure 18. Saída do Filtro Homomórfico</div>
</div>
<div class="paragraph text-justify">
<p>O que pode-se observar analisando o resultado da filtragem é que o fundo da cena que antes estava “estourado” em decorrência da má iluminação, agora está com a luz mais controlada. Além disso, os dois indivíduos da foto, pricipalmente o da frente, ficaram um pouco mais esbranquiçados.</p>
</div>
</div>
</div>
</div>
<h1 id="_parte_iii_segmentação_de_imagens" class="sect0">Parte III: Segmentação de imagens</h1>
<div class="sect1">
<h2 id="_5_detecção_de_bordas_com_o_algoritmo_de_canny">5. Detecção de bordas com o algoritmo de Canny</h2>
<div class="sectionbody">
<div class="sect2">
<h3 id="_5_1_pontilhismo_com_canny">5.1 Pontilhismo com Canny</h3>
<div class="paragraph text-justify">
<p>Buscando usar as bordas produzidas pelo algoritmo de Canny para melhorar a qualidade da imagem pontilhista gerada, criou-se o algoritmo <a href="#cannypoints">cannypoints.cpp</a> que tem como base os algoritmos canny.cpp e pontilhismo.cpp presentes no material do disponibilizado pelo professor.</p>
</div>
<div id="cannypoints" class="listingblock">
<div class="title">cannypoints.cpp</div>
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;iostream&gt;
#include &lt;opencv2/opencv.hpp&gt;
#include &lt;vector&gt;

#define STEP 5
#define JITTER 3
#define RAIO 3

int top_slider = 10;
int top_slider_max = 200;

char TrackbarName[50];

cv::Mat image, border, points;

void on_trackbar_canny(int, void*) {
    cv::Canny(image, border, top_slider, 3 * top_slider);
    cv::imshow("Canny", border);

    points = cv::Mat(image.rows, image.cols, CV_8U, cv::Scalar(255));

    // Desenha pontos na imagem pontilhista
    for (int i = 0; i &lt; image.rows; i += STEP) {
        for (int j = 0; j &lt; image.cols; j += STEP) {
            int x = i + std::rand() % (2 * JITTER) - JITTER + 1;
            int y = j + std::rand() % (2 * JITTER) - JITTER + 1;
            int gray = image.at&lt;uchar&gt;(x, y);
            cv::circle(points, cv::Point(y, x), RAIO, CV_RGB(gray, gray, gray),
                       cv::FILLED, cv::LINE_AA);
        }
    }

    // Usa a posição dos pixels de borda encontrados pelo algoritmo de Canny
    // para desenhar pontos nos respectivos locais na imagem gerada
    for (int i = 0; i &lt; image.rows; i++) {
        for (int j = 0; j &lt; image.cols; j++) {
            if (border.at&lt;uchar&gt;(i, j) &gt; 0) {
                int gray = image.at&lt;uchar&gt;(i, j);
                cv::circle(points, cv::Point(j, i), RAIO, CV_RGB(gray, gray, gray),
                           cv::FILLED, cv::LINE_AA);
            }
        }
    }

    // Aumenta os limiares do algoritmo de Canny
    for (int thresh = top_slider + 10; thresh &lt;= top_slider_max; thresh += 10) {
        cv::Canny(image, border, thresh, 3 * thresh);

        for (int i = 0; i &lt; image.rows; i++) {
            for (int j = 0; j &lt; image.cols; j++) {
                if (border.at&lt;uchar&gt;(i, j) &gt; 0) {
                    int gray = image.at&lt;uchar&gt;(i, j);
                    cv::circle(points, cv::Point(j, i), RAIO / 2, CV_RGB(gray, gray, gray),
                               cv::FILLED, cv::LINE_AA);
                }
            }
        }
    }

    cv::imshow("Pontilhismo", points);
}

int main(int argc, char** argv) {
    image = cv::imread(argv[1], cv::IMREAD_GRAYSCALE);

    sprintf(TrackbarName, "Threshold inferior", top_slider_max);

    cv::namedWindow("Canny", 1);
    cv::createTrackbar(TrackbarName, "Canny",
                       &amp;top_slider,
                       top_slider_max,
                       on_trackbar_canny);

    on_trackbar_canny(top_slider, 0);

    cv::waitKey();
    cv::imwrite("cannyborders.png", border);
    cv::imwrite("pontos.jpg", points);

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>A principal função do código é a on_trackbar_canny, onde estão presentes três conjuntos de for’s. O primeiro deles, percorre a imagem points e adiciona círculos de raio 3 de maneira pseudoaleatória.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">    points = cv::Mat(image.rows, image.cols, CV_8U, cv::Scalar(255));

    // Desenho de círculos na imagem pontilhista
    for (int i = 0; i &lt; image.rows; i += STEP) {
        for (int j = 0; j &lt; image.cols; j += STEP) {
            int x = i + std::rand() % (2 * JITTER) - JITTER + 1;
            int y = j + std::rand() % (2 * JITTER) - JITTER + 1;
            int gray = image.at&lt;uchar&gt;(x, y);
            cv::circle(points, cv::Point(y, x), RAIO, CV_RGB(gray, gray, gray),
                       cv::FILLED, cv::LINE_AA);
        }
    }</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>O par aninhado de for’s seguinte, criteriza de maneira diferente a adição dos círculos que havia sido feita anteriormente. Ele perocerre os pixels da imagem points e ao identficar que trata-se de um pixel de borda, desenha um círculo na posição correspodente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">    // Desenho de círuclos a partir de Canny
    for (int i = 0; i &lt; image.rows; i++) {
        for (int j = 0; j &lt; image.cols; j++) {
            if (border.at&lt;uchar&gt;(i, j) &gt; 0) {
                int gray = image.at&lt;uchar&gt;(i, j);
                cv::circle(points, cv::Point(j, i), RAIO, CV_RGB(gray, gray, gray),
                           cv::FILLED, cv::LINE_AA);
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>O último trecho de for’s, percorre diferentes limiares do algoritmo de Canny utilizando como base o valor do cursor, onde as bordas detectadas por esse algoritmo são então realçadas em points. Isso faz com que seja mostrada uma sequência de imagens pontilhadas, cada uma destacando as bordas com um limiar de detecção diferente.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">// Aumenta os limiares do algoritmo de Canny
    for (int thresh = top_slider + 10; thresh &lt;= top_slider_max; thresh += 10) {
        cv::Canny(image, border, thresh, 3 * thresh);

        for (int i = 0; i &lt; image.rows; i++) {
            for (int j = 0; j &lt; image.cols; j++) {
                if (border.at&lt;uchar&gt;(i, j) &gt; 0) {
                    int gray = image.at&lt;uchar&gt;(i, j);
                    cv::circle(points, cv::Point(j, i), RAIO / 2, CV_RGB(gray, gray, gray),
                               cv::FILLED, cv::LINE_AA);
                }
            }
        }
    }</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>Tendo sido explicitado os principais trechos que compõem o algoritmo parte-se para sua execução. Como indicado, foi escolhida uma foto minha para ser a imagem de entrada.</p>
</div>
<div id="Adson" class="imageblock png">
<div class="content">
<img src="PDI/5/Adson.png" alt="labeling" width="250" height="250">
</div>
<div class="title">Figure 19. Imagem de Entrada cannypoint</div>
</div>
<div class="paragraph text-justify">
<p>Ao executar o algoritmo, a barra de controle do Thresholding inferior encontra-se no canto superior esquerdo, a imagem de entrada com a aplicação do filtro de Canny está à esquerda, e a imagem pontilhista está à direita.</p>
</div>
<div id="cannypoints1" class="imageblock png">
<div class="content">
<img src="PDI/5/cannypoints1.png" alt="cannypoints1" width="450" height="450">
</div>
<div class="title">Figure 20. Execução do cannypoints - Thresholding inferior inicial</div>
</div>
<div class="paragraph text-justify">
<p>Deslocando a barra de Thresholding para direita a detecção de borda torna-se mais restrita e vão se mantendo apenas as bordas mais fortes. Dessa forma, a imagem pontilhista, que tem a criação dos seus pontos dependente da imagem de canny, acaba perdendo detalhes. É possível observar tal comportamento nas Imagens <a href="#cannypoints2">Thresholding inferior = 100</a> e <a href="#cannypoints3">Thresholding inferior = 200</a>.</p>
</div>
<div id="cannypoints2" class="imageblock png">
<div class="content">
<img src="PDI/5/cannypoints2.png" alt="cannypoints2" width="450" height="450">
</div>
<div class="title">Figure 21. Execução do cannypoints - Thresholding inferior = 100</div>
</div>
<div id="cannypoints3" class="imageblock png">
<div class="content">
<img src="PDI/5/cannypoints3.png" alt="cannypoints3" width="450" height="450">
</div>
<div class="title">Figure 22. Execução do cannypoints - Thresholding inferior = 200</div>
</div>
</div>
<div class="sect2">
<h3 id="_5_2_quantização_vetorial_com_k_means">5.2 Quantização vetorial com k-means</h3>
<div class="paragraph text-justify">
<p>Buscando analisar os diferentes resultados gerados a partir do uso do algoritmo K-means foram feitas alterações no programa kmeans.cpp. Então, conforme solicitado, o parâmetro nRodadas foi alterado para 1 e os centros foram iniciados de forma aleatória a partir do parâmetro KMEANS_RANDOM_CENTERS.</p>
</div>
<div class="listingblock">
<div class="content">
<pre class="highlight"><code class="language-CPP" data-lang="CPP">#include &lt;cstdlib&gt;
#include &lt;opencv2/opencv.hpp&gt;

int main(int argc, char** argv) {
    int nClusters = 8, nRodadas = 1;

    cv::Mat img = cv::imread(argv[1], cv::IMREAD_COLOR);
    if (img.empty()) {
        std::cout &lt;&lt; "Erro abrindo imagem " &lt;&lt; argv[1] &lt;&lt; std::endl;
        return EXIT_FAILURE;
    }

    cv::Mat samples(img.rows * img.cols, 3, CV_32F);

    for (int y = 0; y &lt; img.rows; y++) {
        for (int x = 0; x &lt; img.cols; x++) {
            for (int z = 0; z &lt; 3; z++) {
                samples.at&lt;float&gt;(y + x * img.rows, z) = img.at&lt;cv::Vec3b&gt;(y, x)[z];
            }
        }
    }

    for (int i = 0; i &lt; 10; i++) {
        cv::Mat rotulos, centros;

        cv::kmeans(samples, nClusters, rotulos,
                   cv::TermCriteria(cv::TermCriteria::EPS | cv::TermCriteria::COUNT,
                                    10000, 0.0001),
                   nRodadas, cv::KMEANS_RANDOM_CENTERS, centros);

        cv::Mat rotulada(img.size(), img.type());
        for (int y = 0; y &lt; img.rows; y++) {
            for (int x = 0; x &lt; img.cols; x++) {
                int indice = rotulos.at&lt;int&gt;(y + x * img.rows, 0);
                rotulada.at&lt;cv::Vec3b&gt;(y, x)[0] = (uchar)centros.at&lt;float&gt;(indice, 0);
                rotulada.at&lt;cv::Vec3b&gt;(y, x)[1] = (uchar)centros.at&lt;float&gt;(indice, 1);
                rotulada.at&lt;cv::Vec3b&gt;(y, x)[2] = (uchar)centros.at&lt;float&gt;(indice, 2);
            }
        }

        std::string nomeSaida = "sushi-kmeans" + std::to_string(i) + ".jpg";

        cv::imwrite(nomeSaida, rotulada);

    }

    //ImageMagick sendo usado para criar um GIF a partir das imagens
    system("convert -delay 100 -loop 0 sushi-kmeans*.jpg output.gif");

    return 0;
}</code></pre>
</div>
</div>
<div class="paragraph text-justify">
<p>No código, implementou-se um loop para fazer com que o Kmeans seja executado 10 vezes, dessa forma, cada iteração gera uma imagem que é salva na memória. Por fim, utilizou-se a ferramenta ImageMagick para converter as imagens geradas em um arquivo GIF.</p>
</div>
<div class="paragraph text-justify">
<p>Como exemplo de aplicação, tem-se a imagem de entrada  <a href="#sushi">sushi.jpg</a> e a saída <a href="#output_kmeans">output_kmeans.gif</a></p>
</div>
<div id="sushi" class="imageblock jpg">
<div class="content">
<img src="PDI/5/sushi.jpg" alt="sushi" width="450" height="450">
</div>
<div class="title">Figure 23. Imagem de entrada para o algoritmo Kmeans</div>
</div>
<div id="output_kmeans" class="imageblock gif">
<div class="content">
<img src="PDI/5/output_kmeans.gif" alt="output_kmeans" width="450" height="450">
</div>
<div class="title">Figure 24. GIF de saída do algoritmo Kmeans</div>
</div>
<div class="paragraph">
<p>De posse do GIF é possível confirmar que o Kmeans gera resultados diferentes para cada iteração. Isso ocorre porque a definição dos centros de forma aleatória influencia a formação inicial dos clusters e, consequentemente, afeta a solução final.</p>
</div>
</div>
</div>
</div>
</div>
<div id="footer">
<div id="footer-text">
Last updated 2023-12-03 20:22:35 -0300
</div>
</div>
</body>
</html>